import type { Modding } from "@flamework/core";
import type { Entity } from "@rbxts/jecs";
import * as ecs from "@rbxts/jecs";

export const { ChildOf, pair } = ecs

import { Players, RunService } from "@rbxts/services";

interface State {
    cleanup: Callback;
    state: Record<string, unknown>;
}

interface StackFrame {
    node: Record<string, State>;
}

const stack: Array<StackFrame> = [];

function addStackFrame(node: Record<string, State>): void {
    const frame: StackFrame = {
        node,
    };
    stack.push(frame);
}

function popStackFrame(): void {
    stack.pop();
}

function cleanupAll(): void {
    const current = stack[stack.size() - 1]!;

    for (const [key] of pairs(current.node)) {
        const state = current.node[key]!;
        for (const [discriminator] of pairs(state.state)) {
            state.cleanup(state.state[discriminator]);
        }
    }
}

export function start(node: Record<string, State>, func: () => void): void {
    addStackFrame(node);
    func();
    cleanupAll();
    popStackFrame();
}

// eslint-disable-next-line ts/explicit-function-return-type -- Returns unknown.
export function useHookState(
    key: string,
    discriminator: unknown,
    callback: (state: unknown) => void,
) {
    const current = stack[stack.size() - 1]!;
    let storage = current.node[key];
    if (!storage) {
        storage = { cleanup: callback, state: {} };
        current.node[key] = storage;
    }

    discriminator ??= key;
    const stringifiedKey = tostring(discriminator);

    let state = storage.state[stringifiedKey];
    if (state === undefined) {
        state = {};
        storage.state[stringifiedKey] = state;
    }

    return state;
}

interface Storage {
    expiry: number;
}

function cleanup(storage: Storage): boolean {
    return os.clock() < storage.expiry;
}

interface ThrottleStorage {
    expiry?: number;
    time?: number;
}

const STABLE_DISCRIMINATOR = {};

/**
 * Utility for easy time-based throttling.
 *
 * Accepts a duration, and returns `true` if it has been that long since the
 * last time this function returned `true`. Always returns `true` the first
 * time.
 *
 * @param seconds - The number of seconds to throttle for.
 * @param discriminator -- A unique value to additionally key by.
 * @param key - An automatically generated key to store the throttle state.
 * @returns - Returns true every x seconds, otherwise false.
 * @metadata macro
 */
export function useThrottle(
    seconds: number,
    discriminator?: unknown,
    key?: Modding.Caller<"uuid">,
): boolean {
    assert(key);

    const storage = useHookState(
        key,
        discriminator ?? STABLE_DISCRIMINATOR,
        cleanup as never,
    ) as ThrottleStorage;

    if (storage.time === undefined || os.clock() - storage.time >= seconds) {
        storage.time = os.clock();
        storage.expiry = os.clock() + seconds;
        return true;
    }

    return false;
}

export interface Relation<T = Tag> {
    type: "FLAMECS_RELATION";
    value: T;
}

type Id<T = undefined> = {
    __T: T;
} & number;

export interface Tag {
    type: "FLAMECS_TAG";
}

interface Signal<T extends Array<unknown>> {
    connect: (func: (...args: T) => void) => void;
    fire: (...args: T) => void;
}

const components = new Map<string, Id<unknown>>();

function createSignal<T extends Array<unknown>>(): Signal<T> {
    const listeners = new Array<(...args: T) => void>();
    const fire = (...args: T): void => {
        for (const func of listeners) {
            func(...args);
        }
    };

    const connect = (func: (...args: T) => void): void => {
        listeners.push(func);
    };

    return {
        connect,
        fire,
    };
}

const registry = new ecs.World();
export const signals: {
    added: Record<Id<unknown>, Signal<Array<unknown>>>;
    changed: Record<Id<unknown>, Signal<Array<unknown>>>;
    removed: Record<Id<unknown>, Signal<Array<unknown>>>;
} = {
    added: {},
    changed: {},
    removed: {},
};

/**
 * A component is something that is added to an entity. Components can simply
 * tag an entity ("this entity is an Npc"), attach data to an entity ("this
 * entity is at Position Vector3.new(10, 20, 30)") and create relationships
 * between entities ("bob Likes alice") that may also contain data ("bob Eats 10
 * apples").
 *
 * @template T - The type of the component.
 * @param key - Flamework autogenerated key.
 * @returns The component entity id.
 * @metadata macro
 */
export function component<T>(key?: Modding.Generic<T, "id">): Id<T> {
    assert(key);
    let id = components.get(key) as Id<T> | undefined;
    if (id === undefined) {
        id = registry.component();
        components.set(key, id);
        const addedSignal = createSignal();
        const removedSignal = createSignal();
        const changedSignal = createSignal();
        signals.added[id] = addedSignal;
        signals.removed[id] = removedSignal;
        signals.changed[id] = changedSignal;

        registry.set(id, ecs.OnAdd, entity => {
            addedSignal.fire(entity);
        });
        registry.set(id, ecs.OnRemove, entity => {
            removedSignal.fire(entity);
        });
        registry.set(id, ecs.OnSet, (entity, data) => {
            changedSignal.fire(entity, data);
        });
    }

    return id;
}

interface Changes<T> {
    added: (entity: number) => void;
    changed: (entity: number, current: T, previous: T) => void;
    removed: (entity: number) => void;
}

export function createTracker<T>(key?: Modding.Generic<T, "id">) {
    assert(key !== undefined);
    const id = component<T>();

    let previous = new Array<T>();

    const entitiesAdded = new Array<number>();
    const entitiesRemoved = new Array<number>();
    let changedEntities = new Array<number>();
    let changedData = new Array<T>();

    (signals.added[id] as Signal<[number]>).connect((entity: number) => {
        entitiesAdded.push(entity);
    });

    (signals.removed[id] as Signal<[number]>).connect((entity: number) => {
        entitiesRemoved.push(entity);
    });

    (signals.changed[id] as Signal<[number, T]>).connect((entity: number, data: T) => {
        const length = changedData.size();
        changedEntities[length] = entity;
        changedData[length] = data;
    });

    const changes: Changes<T> = {
        added: () => {
            let index = 0;
            return () => {
                const entity = entitiesAdded[index];
                index++;
                return entity;
            };
        },
        changed: () => {
            let index = 0;
            return () => {
                const entity = changedEntities[index];
                if (entity === undefined) {
                    return;
                }

                const data = changedData[index];
                const old = previous[index];
                index++;
                return $tuple(entity, data, old);
            };
        },
        removed: () => {
            let index = 0;
            return () => {
                const entity = entitiesRemoved[index];
                index++;
                return entity;
            };
        },
    };

    return (func: Callback) => {
        func(changes);
        previous = changedData;
        changedEntities = new Array<number>();
        changedData = new Array<T>();
    };
}

export function added<T>(id: Id<T>): Signal<[number, T]> {
    return signals.added[id] as Signal<[number, T]>;
}

export function removed<T>(id: Id<T>): Signal<[number]> {
    return signals.removed[id] as Signal<[number]>;
}

/**
 * Creates a new entity with the specified components.
 *
 * @template T - The type of the components.
 * @param bundle - The components to add to the entity.
 * @param keys - Flamework autogenerated keys.
 * @returns The entity id.
 * @metadata macro
 */
export function spawn<T extends Array<unknown>>(
    bundle?: T,
    keys?: Array<unknown> extends T ? Modding.Many<{ [K in keyof T]: Modding.Generic<T[K], "id"> }> : undefined,
): number {
    const entity = registry.entity();
    if (keys && bundle) {
        const size = bundle.size();
        for (const index of $range(0, size - 1)) {
            const key = keys[index];
            const data = bundle[index];
            const id = component(key);
            registry.set(entity, id, data);
        }
    }

    return entity;
}

/**
 * Adds or changes the entity's component.
 *
 * @template T - The type of the component.
 * @param entity - The entity to modify.
 * @param value - The data of the component's type.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function set<T>(entity: number, value: T, key?: Modding.Generic<T, "id">): void {
    const id = component(key);
    registry.set(entity as Entity, id, value);
}

/**
 * Adds a component ID to the entity.
 *
 * This operation adds a single (component) id to an entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity to add the component to.
 * @param key - Flamework autogenerated key.
 * @info This function is idempotent, meaning if the entity already has the id, this operation will have no side effects.
 * @metadata macro
 */
export function add<T>(entity: number, key?: Modding.Generic<T, "id">): void {
    const id = component(key);
    registry.add(entity as Entity, id);
}

/**
 * Removes the component ID from the entity.
 *
 * @template T - The type of the component.
 * @param entity - The entity to remove the component from.
 * @param key - Flamework autogenerated key.
 * @metadata macro
 */
export function remove<T>(entity: number, key?: Modding.Generic<T, "id">): void {
    const id = component(key);
    registry.remove(entity as Entity, id);
}

/**
 * Returns the data for the component data the corresponding entity, nil if
 * entity does not have the ID or was a tag.
 *
 * @template T - The type of the component.
 * @param entity - The entity to get the component data for.
 * @param key - Flamework autogenerated key.
 * @returns Returns the data for the component data the corresponding entity,
 *   nil if entity does not have the id or was a tag.
 * @metadata macro
 */
export function get<T>(entity: number, key?: Modding.Generic<T, "id">): T | undefined {
    const id = component(key);
    return registry.get(entity as Entity, id);
}

/**
 * Returns whether the entity has the given id.
 *
 * @template T - The type of the component.
 * @param entity - The entity to check.
 * @param key - Flamework autogenerated key.
 * @returns Whether the entity has the id.
 * @metadata macro
 */
export function has<T>(entity: number, key?: Modding.Generic<T, "id">): boolean {
    const id = component(key);
    return registry.has(entity as Entity, id);
}

// Full credits to @fireboltofdeath for all of these types. */
export interface Without<T> {
    _flamecs_without: T;
}
export interface With<T> {
    _flamework_with: T;
}

type Skip<T extends Array<unknown>> = T extends [unknown, ...infer R] ? R : [];

interface Bounds {
    query: Array<unknown>;
    with: Array<unknown>;
    without: Array<unknown>;
}
type BoundsTuple<T> = T extends { length: number } & ReadonlyArray<unknown> ? T : [];
type PushBound<B extends Bounds, K extends keyof B, V> = Omit<B, K> &
    Record<
        K,
        V extends ReadonlyArray<unknown> ? [...BoundsTuple<B[K]>, ...V] : [...BoundsTuple<B[K]>, V]
    >;

type Calculate<T extends Array<unknown>, B extends Bounds = Bounds> = T extends []
    ? { [k in keyof B]: BoundsTuple<B[k]> }
    : T[0] extends Without<infer V>
    ? Calculate<Skip<T>, PushBound<B, "without", V>>
    : T[0] extends With<infer V>
    ? Calculate<Skip<T>, PushBound<B, "with", V>>
    : Calculate<Skip<T>, PushBound<B, "query", T[0]>>;
type ToIds<T> = T extends []
    ? undefined
    : Modding.Many<{
        [k in keyof T]: Modding.Generic<T[k], "id">;
    }>;

/**
 * A World contains entities which have components. The World is queryable and
 * can be used to get entities with a specific set of components.
 *
 * @template T - The components that the entity must have.
 * @template With - The components that the entity must have.
 * @template Without - The components that the entity must not have.
 * @param terms - Flamework autogenerated key.
 * @param filterWithout - Flamework autogenerated key.
 * @param filterWith - Flamework autogenerated key.
 * @returns The query object.
 * @metadata macro
 */
interface Query {
    <T extends Array<unknown>>(
        terms?: ToIds<Calculate<T>["query"]>,
        filterWithout?: ToIds<Calculate<T>["without"]>,
        filterWith?: ToIds<Calculate<T>["with"]>,
    ): QueryHandle<Reconstruct<Calculate<T>["query"]>>;

    rt: <U extends Array<ecs.Entity>>(...args: U) => ecs.Query<ecs.InferComponents<U>>;
}
export const query: Query = {
    rt: <T extends Array<ecs.Entity>>(...args: T) => registry.query(...args),
} as Query;

(query as unknown as { __call: Callback }).__call = <T extends Array<unknown>>(
    terms?: ToIds<Calculate<T>["query"]>,
    filterWithout?: ToIds<Calculate<T>["without"]>,
    filterWith?: ToIds<Calculate<T>["with"]>,
) => {
    assert(terms !== undefined);
    const ids = new Array<number>();
    for (const key of terms) {
        const id = component(key);
        ids.push(id);
    }

    let result = registry.query(...ids);
    if (filterWithout !== undefined) {
        const filterWithoutIds = new Array<number>();
        for (const key of filterWithout) {
            const id = component(key);
            filterWithoutIds.push(id);
        }

        result = result.without(...filterWithoutIds);
    }

    if (filterWith !== undefined) {
        const filterWithIds = new Array<number>();
        for (const key of filterWith) {
            const id = component(key);
            filterWithIds.push(id);
        }

        result = result.with(...filterWithIds);
    }

    return result as never;
};

export function despawn(entity: number): void {
    registry.delete(entity as never);
}

for (const [entity] of query<[Vector3]>()) {
    print(entity);
}

for (const [entity, vec] of query.rt(component<Vector3>())) {
    print(entity, vec)
}

type DynamicBundle = Array<Id<unknown>>;

type QueryIter<T extends Array<unknown>> = IterableFunction<LuaTuple<[number, ...T]>>;

type QueryHandle<T extends Array<unknown>> = {
    without: (this: QueryHandle<T>, ...exclude: DynamicBundle) => QueryHandle<T>;
} & QueryIter<T>;

// eslint-disable-next-line ts/no-unused-vars -- Placeholder for the future.
let isPreloading = false;
// RuntimeLib, which is required to import packages
const tsImpl = (_G as Map<unknown, unknown>).get(script) as {
    import: (...modules: Array<LuaSourceContainer>) => unknown;
};

/** @ignore */
// eslint-disable-next-line ts/no-unused-vars -- Used for internal purposes.
export function _addPaths(paths: Array<Array<string>>): void {
    const preloadPaths = new Array<Instance>();
    for (const argument of paths) {
        const service = argument.shift();
        let currentPath: Instance = game.GetService(service as keyof Services);
        if (service === "StarterPlayer") {
            if (argument[0] !== "StarterPlayerScripts") {
                throw "StarterPlayer only supports StarterPlayerScripts";
            }

            if (!RunService.IsClient()) {
                throw "The server cannot load StarterPlayer content";
            }

            currentPath = Players.LocalPlayer.WaitForChild("PlayerScripts");
            argument.shift();
        }

        for (let index = 0; index < argument.size(); index++) {
            currentPath = currentPath.WaitForChild(argument[index]!);
        }

        preloadPaths.push(currentPath);
    }

    const preload = (moduleScript: ModuleScript): void => {
        isPreloading = true;
        const startTime = os.clock();
        const [success, value] = pcall(() => tsImpl.import(script, moduleScript));
        const endTime = math.floor((os.clock() - startTime) * 1000);
        isPreloading = false;
        if (!success) {
            throw `${moduleScript.GetFullName()} failed to preload (${endTime}ms): ${value}`;
        }
    };

    for (const path of preloadPaths) {
        if (path.IsA("ModuleScript")) {
            preload(path);
        }

        for (const instance of path.GetDescendants()) {
            if (instance.IsA("ModuleScript")) {
                preload(instance);
            }
        }
    }
}
/**
 * Preload the specified paths by requiring all ModuleScript descendants.
 *
 * @param path - The path to preload.
 * @param meta - Flamework autogenerated key.
 * @metadata macro intrinsic-arg-shift {@link _addPaths intrinsic-flamework-rewrite}
 */
export declare function addPaths<T extends string>(
    path: T,
    meta?: Modding.Intrinsic<"path", [T]>,
): void;
